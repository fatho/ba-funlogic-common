not :: Bool -> Bool
not x = case x of
  True -> False
  False -> True

id :: forall a.a -> a
id x = x

tMap :: forall a b.(a -> b) -> Pair a a -> Pair b b
tMap f x = case x of Pair a b -> Pair<:b,b:> (f a) (f b)

filter :: forall a.(a -> Bool) -> [a] -> [a]
filter f x = case x of
  Nil -> Nil<:a:>
  Cons y ys -> case f y of
    True -> Cons<:a:> y (filter<:a:> f ys)
    False -> filter<:a:> f ys

inc :: Nat -> Nat
inc x = x + 1

foo :: Pair Nat Nat
foo = tMap<:Nat,Nat:> inc (Pair<:Nat,Nat:> 1 3)

pred :: Nat -> Bool
pred x = not (x == 1)

bar :: [Nat]
bar = filter<:Nat:> pred [1,4,1,1,2,1,1]<:Nat:>

maybeInc :: Nat -> Nat
maybeInc x = let c :: Bool free in case c of
  True  -> x + 1
  False -> x

maybeInc2 :: Nat -> Nat
maybeInc2 = let c :: Bool free in case c of
  True  -> inc
  False -> id<:Nat:>

doubleInc :: Nat -> Nat
doubleInc y = let x = maybeInc y in x + x

dup :: forall a.Data a => Pair a a
dup = let x :: a free in Pair<:a,a:> x x

dup2 :: forall a.Data a => (a,a)
dup2 = let x :: a free in
       let y :: a free in
       Pair<:a,a:> x y

{- Just a boring comment -}

{--}
{- ^ comments may be empty -}

{- comments can be {- nested -} -}

{- multi-line
   comments
   are no problem,
   not {- even
   with nesting -}
-}

{- special chars - in comments { are handled } correctly --}
