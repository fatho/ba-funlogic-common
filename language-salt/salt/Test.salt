data Foo a b c
  = Foo (Bar a b -> Bar b c -> Bar a c)
  | Baz

data Bar a b = Bar (Set a) (Set b)

not :: Bool -> Bool
not = \x :: Bool -> case x of
              True -> False
              False -> True

not2 :: Bool -> Bool
not2 = \x :: Bool -> case case x of { True -> False
; False -> True } of
  True  -> True
  False -> False

tMap :: forall a b.(a -> b) -> (a,a) -> (b,b)
tMap = \f :: (a->b) ->
       \x :: (a,a)  -> case x of (a,b) -> (f a, f b)

sMap :: forall a b.(a -> b) -> Set a -> Set b
sMap = \f :: (a -> b) ->
       \xs :: {a} -> xs >>= \x :: a -> {f x}

filter :: forall a.(a -> Bool) -> [a] -> [a]
filter = \f :: (a -> Bool) ->
         \x :: [a] -> case x of
           Nil -> Nil
           Cons(y,ys) -> case f y of
             True -> Cons(y, filter<:a:> f ys)
             False -> filter<:a:> f ys

foo :: (Int, Int)
foo = tMap<:Int,Int:> (\x :: Int -> x + 1) (1,3)

bar :: [Int]
bar = filter (\x :: Int -> not (x == 1)) [1,4,1,1,2,1,1]<:Int:>

{- Just a boring comment -}

{--}
{- ^ comments may be empty -}

{- comments can be {- nested -} -}

{- multi-line
   comments
   are no problem,
   not {- even
   with nesting -}
-}

{- special chars - in comments { are handled } correctly --}
